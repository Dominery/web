# Class

JavaScript 语言中，生成实例对象的传统方法是通过构造函数。ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过`class`关键字，可以定义类。

ES6 的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

类的所有方法都定义在类的`prototype`属性上面。

## 基本使用

### 普通构造函数区别

与函数一样，类也可以使用表达式的形式定义。

`name`属性总是返回紧跟在`class`关键字后面的类名。

不同点

* 类必须使用`new`调用，否则会报错
* 类的内部所有定义的方法，都是不可枚举的
* 类不存在变量提升

### 类的实例

类的属性和方法，除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上。

类的所有实例共享一个原型对象。

#### 公共实例字段

[ES2022](https://github.com/tc39/proposal-class-fields) 为类的实例属性，又规定了一种新写法。实例属性现在除了可以定义在`constructor()`方法里面的`this`上面，也可以定义在类内部的最顶层，不需要在实例属性前面加上`this`。

所有实例对象自身的属性都定义在类的头部，看上去比较整齐。

#### constructor()

`constructor()`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor()`方法，如果没有显式定义，一个空的`constructor()`方法会被默认添加。

`constructor()`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。

#### getter和setter

与 ES5 一样，在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。

存值函数和取值函数是设置在属性的 Descriptor 对象上的。

#### new.target

ES6 为`new`命令引入了一个`new.target`属性，该属性一般用在构造函数之中，返回`new`命令作用于的那个构造函数。如果构造函数不是通过`new`命令或`Reflect.construct()`调用的，`new.target`会返回`undefined`，因此这个属性可以用来确定构造函数是怎么调用的。

类继承父类时，`new.target`会返回子类。可以写出不能独立使用、必须继承后才能使用的类。

### 类的属性

ES2022引入了静态类字段和静态方法。

#### 静态方法

如果在一个方法前，加上`static`关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。

* 如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。
* 如果静态方法包含`this`关键字，这个`this`指的是类，而不是实例。
* 父类的静态方法，可以被子类继承。

#### 静态属性

静态属性指的是 Class 本身的属性，即`Class.propName`，而不是定义在实例对象（`this`）上的属性。

ES2022提供了类的静态属性，写法是在实例属性的前面，加上`static`关键字。

实例不能访问静态字段和方法，静态属性和方法可以被继承。

#### 静态块

静态属性的一个问题是，如果它有初始化逻辑，这个逻辑要么写在类的外部，要么写在`constructor()`方法里面。

ES2022 引入了[静态块](https://github.com/tc39/proposal-class-static-block)（static block），允许在类的内部设置一个代码块，在类生成时运行且只运行一次，主要作用是对静态属性进行初始化。

* 每个类允许有多个静态块，每个静态块中只能访问之前声明的静态属性
* 静态块的内部不能有`return`语句
* 静态块内部可以使用类名或`this`，指代当前类

### 私有化

私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。早期的 ES6 不提供，只能通过变通方法模拟实现。

1. 在命名上加以区别。
2. 将私有方法移出类
3. 利用`Symbol`值的唯一性，将私有方法的名字命名为一个`Symbol`值

[ES2022](https://github.com/tc39/proposal-class-fields)正式为`class`添加了私有属性和私有方法，方法是在属性名或方法之前使用`#`表示。

* 如果在类的外部使用，就会报错
* 不管在类的内部或外部，读取一个不存在的私有属性，也都会报错
* 私有属性也可以设置 getter 和 setter 方法
* 私有属性不限于从`this`引用，只要是在类的内部，实例也可以引用私有属性
* 私有属性和私有方法前面，也可以加上`static`关键字，表示这是一个静态的私有属性或私有方法

#### in运算符

直接访问某个类不存在的私有属性会报错，但是访问不存在的公开属性不会报错。这个特性可以用来判断，某个对象是否为类的实例。

[ES2022](https://github.com/tc39/proposal-private-fields-in-in) 改进了`in`运算符，使它也可以用来判断私有属性。

* 判断私有属性时，`in`只能用在类的内部
* 子类从父类继承的私有属性，也可以使用`in`运算符来判断
* 对于修改原型链形成的继承，子类都取不到父类的私有属性

## 继承

Class 可以通过`extends`关键字实现继承，让子类继承父类的属性和方法。

### constructor()

ES6 规定，子类必须在`constructor()`方法中调用`super()`，否则就会报错。这是因为子类自己的`this`对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用`super()`方法，子类就得不到自己的`this`对象。

在子类的构造函数中，只有调用`super()`之后，才可以使用`this`关键字，否则会报错。

如果子类没有定义`constructor()`方法，这个方法会默认添加，并且里面会调用`super()`。

### 属性和方法

#### 私有属性和方法

父类所有的属性和方法，都会被子类继承，除了私有的属性和方法。

子类无法继承父类的私有属性，或者说，私有属性只能在定义它的 class 里面使用。

#### 静态属性和方法

父类的静态属性和静态方法，也会被子类继承。

* 静态属性是通过软拷贝实现继承的。
* 如果父类的静态属性的值是一个对象，那么子类的静态属性也会指向这个对象

### super关键字

`super`这个关键字，既可以当作函数使用，也可以当作对象使用。

#### 作为函数调用

`super`作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次`super`函数。

`super`虽然代表了父类`A`的构造函数，但是返回的是子类`B`的实例，即`super`内部的`this`指的是`B`的实例

* `super()`只能用在子类的构造函数之中，用在其他地方就会报错。

#### 作为对象

`super`作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

ES6 规定，在子类普通方法中通过`super`调用父类的方法时，方法内部的`this`指向当前的子类实例。

* 由于`super`指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过`super`调用的。
* 如果通过`super`对某个属性赋值，这时`super`就是`this`，赋值的属性会变成子类实例的属性。
* 如果`super`作为对象，用在静态方法之中，这时`super`将指向父类，而不是父类的原型对象。
* 在子类的静态方法中通过`super`调用父类的方法时，方法内部的`this`指向当前的子类，而不是子类的实例。

### 继承属性

#### 类的继承

Class 作为构造函数的语法糖，同时有`prototype`属性和`__proto__`属性，因此同时存在两条继承链。

1. 子类的`__proto__`属性，表示构造函数的继承，总是指向父类。

2. 子类`prototype`属性的`__proto__`属性，表示方法的继承，总是指向父类的`prototype`属性。

```javascript
class A {
}

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === Object.prototype // true
```

#### 实例继承

子类实例的`__proto__`属性的`__proto__`属性，指向父类实例的`__proto__`属性。

### 原生构造函数继承

原生构造函数是指语言内置的构造函数，通常用来生成数据结构。

- Boolean()
- Number()
- String()
- Array()
- Date()
- Function()
- RegExp()
- Error()
- Object()

ES5 是先新建子类的实例对象`this`，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。

ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象`this`，然后再用子类的构造函数修饰`this`，使得父类的所有行为都可以继承。