# 运算符

## 新增运算符

### 可选链运算符

可选链运算符是`?.`，能够降低对象多层属性安全访问的复杂度。

可选链运算符特性：

1. 短路机制，如果可选链运算符左侧操作数的求值结果为undefined或null，那么右侧的操作数不会再被求值
2. `?.`后不能为数字，否则作为三元运算符

可选链运算符有以下三种语法形式：

* 可选的静态属性访问，如`obj.prop`
* 可选的计算属性访问，如`obj?.[expr]`
* 可选的函数调用或方法调用，如`fn?.()`

### 空值合并运算符

空值合并运算符是`??`，该运算符为二元运算符，当且仅当运算符左侧操作数类型为null或undifined，返回右侧操作数，否则返回左侧操作数。

`??`与`||`之间的区别在于`||`存在隐式类型转换，如果第一个值转换后的值为false，那么会返回第二个值。

## 基本运算符

### 算术运算符

| 运算符 | 意义 |
| ------ | ---- |
| +      | 加   |
| -      | 减   |
| *      | 乘   |
| /      | 除   |
| %      | 取余 |

默认情况，乘除法的优先级要高于加法和减法;必要时可以使用圆括号来改变运算的顺序。

* 加号的两种作用

  如果加号两边的操作数都是数字，则为“加法”，否则为连字符

* 取余运算

  a % b表示求a除以b的余数。取余运算中，如果b为负数，则其结果与b为正数时相同。a、b可以是浮点数。

* IEEE754

  JavaScript使用了IEEE754二进制浮点数算术标准，这会使一些个别的小数运算产生“丢失精度”问题。

  解决办法:在进行小数运算时，要调用数字的toFixed()方法保留指定的小数位数

* 幂和开根号

  JavaScript中没有提供幂计算、开根号的运算符。需要使用Math对象的pow和sqrt方法进行计算。如果对负数进行开根运算，返回值为NaN。

* 取整

  Math.ceil()向上取整; Math.floor()向下取整

### 关系运算符

| 运算符 | 意义     |
| ------ | -------- |
| >      | 大于     |
| <      | 小于     |
| >=     | 大于等于 |
| <=     | 小于等于 |
| ==     | 等于     |
| !=     | 不等于   |
| ===    | 全等于   |
| !==    | 不全等于 |

* 连续比较

  js中变量不能像python一样进行连续比较，需要通过逻辑运算符隔开，如果书写连续比较，则会按照顺序计算。

#### 相等比较

基本类型进行相等判断时，会比较值是否相等

引用类型进行相等判断时，会比较址是否相等，也就是说它会比较是否为内存中的同一个东西

**相等与全等**

两个等号运算符不比较值的类型，它会进行隐式转换，将值转换为同一类型后，比较值是否相等

> null和undefined用==进行比较涉及隐式强制类型转换，此两者比较后值相等。
>
> NaN作为一个特殊的数字类型值，它不自等

三个等号=运算符，不仅比较值是否相同，也比较类型是否相同

**隐式类型转换**

在js中，当运算符在运算时，如果两边数据不统一，就无法计算，这时编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算，这种无需程序员手动转换的方式就称为隐式类型转换。

如果参与数学运算的某操作数不是数字型且该数学运算不是加法，那么JavaScript会自动将此操作数转换为数字型。

隐式转换的本质是内部调用Number()函数

#### 引用值相等函数

下面这个函数可以判断两个引用类型的值是否相等。

```js
function deepEqual(value1,value2){
    if(value1===value2)return true;
    else if(value1===null || value2===null)return false;
    else if(typeof value1==="object" && typeof value2==="object")return objAttrEqual(value1,value2);
    else return false;
    
    function objAttrEqual(objA,objB){
        let lengthObjB= 0
        for(let attr in objB){
            lengthObjB += 1;
            if(! (attr in objA) || 			!deepEqual(objA[attr],objB[attr]))return false;
        }
        return lengthObjB===Object.keys(objA).length;
	}
}
```



### 逻辑运算符

| 运算符 | 意义 |
| ------ | ---- |
| !      | 非   |
| &&     | 与   |
| \|\|   | 或   |

与或运算返回的不一定是布尔值，而是返回参与运算的一个值。

非运算返回的是布尔值。

* 短路计算

  a && b运算中:a真，表达式值为b;a假，表达式值为a

  a || b运算中: a真，表达式值为a; a假，表达式值为b

* 运算顺序

  非 > 与 > 或

### 赋值运算符

| 运算符             | 意义     |
| ------------------ | -------- |
| =                  | 赋值     |
| +=、-=、*=、/=、%= | 快捷赋值 |
| ++                 | 自增运算 |
| --                 | 自减运算 |

* 赋值操作返回的值

  赋值操作都会产生值

  1. 等号赋值后面的值将作为返回值。因此可以连续对多个变量赋值。
  2. 快速赋值已经运算后的变量值将作为返回值。
  3. 自增自减运算如果在变量后面，返回未运算的值，如果在变量前面，返回运算后的值

  ```javascript
  var a,b;
  a = b = 5; //a=5,b=5
  a += b+= 5; //b=10,a=15
  b = a++; // b=15,a=16
  a = ++b;// a= 16, b=16
  ```

