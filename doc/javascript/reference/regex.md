# 正则表达式

正则表达式(regular expression)描述了字符串的“构成模式”，经常被用于检查字符串是否符合预定的格式要求

正则表达式“按位”描述规则，是指它是一位一位的描述字符串的构成形式

使用typeof运算符检查正则表达式的类型，结果是object

## 基本使用

### 创建

1. 使用`/pattern/flags`的语法形式，可以快速创建正则表达式

2. 使用构造函数的形式，创建正则表达式

   > 使用该方法创建正则表达式需要对反斜杠进行转义
   
   * 参数是字符串，第二个参数表示正则表达式的修饰符
   * 参数是一个正则表达式，es5不允许使用第二个参数添加修饰符，否则报错，返回原有正则表达式的拷贝；es6允许使用第二个参数指定修饰符。

### 实例属性

正则对象的实例属性分成两类。

一类是修饰符相关。

- `RegExp.prototype.ignoreCase`：返回一个布尔值，表示是否设置了`i`修饰符。
- `RegExp.prototype.global`：返回一个布尔值，表示是否设置了`g`修饰符。
- `RegExp.prototype.multiline`：返回一个布尔值，表示是否设置了`m`修饰符。
- `RegExp.prototype.flags`：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。

另一类是与修饰符无关的属性。

- `RegExp.prototype.lastIndex`：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文。
- `RegExp.prototype.source`：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。

### 正则方法

ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：`match()`、`replace()`、`search()`和`split()`。

ES6 将这 4 个方法，在语言内部全部调用`RegExp`的实例方法，从而做到所有与正则相关的方法，全都定义在`RegExp`对象上。

#### 实例方法

| 方法   | 说明                                                     |
| ------ | -------------------------------------------------------- |
| test() | 测试某字符串是否匹配正则表达式，返回布尔值               |
| exec() | 根据正则表达式，在字符串中进行查找，返回结果数组或者null |

##### test()

返回一个布尔值，表示当前模式是否能匹配参数字符串。

如果正则表达式带有`g`修饰符，则每一次`test`方法都从上一次结束的位置开始向后匹配。

* 带有`g`修饰符时，正则表达式内部会记住上一次的`lastIndex`属性，这时不应该更换所要匹配的字符串

##### exec()

exec()方法如果无匹配返回undifined，否则返回一个数组，数组第一个元素是匹配的字符串，后续元素依次是组匹配的字符串，数组还有个index属性，为匹配字符串的下标，input属性是原始字符串。

exec()方法特点是，有“g”修饰符的正则表达式将自动成为“有状态”的，这意味着可以对单个字符串中的多次匹配结果进行逐条的遍历。

```javascript
let str = 'abc12345defg234h345';
let regexp = /\d+/g;
let result;
while(result = regexp.exec(str)){
    console.log(result);
}
```

#### 字符串方法

| 方法       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| search()   | 在字符串中根据正则表达式进行查找匹配，返回首次匹配到的位置索引，测试不到则返回-1 |
| match()    | 在字符串中根据正则表达式进行查找匹配，返回一个数组，找不到则返回null |
| replace()  | 使用替换字符串替换掉匹配到的子字符串，可以使用正则表达式     |
| split()    | 分隔字符串为数组，可以使用正则表达式                         |
| matchAll() | 返回一个迭代器取出字符串的所有匹配                           |

##### match()

字符串实例对象的`match`方法对字符串进行正则匹配，返回匹配结果。

字符串的`match`方法与正则对象的`exec`方法非常类似：匹配成功返回一个数组，匹配失败返回`null`。

如果正则表达式带有`g`修饰符，则该方法与正则对象的`exec`方法行为不同，会一次性返回所有匹配成功的结果，如果同时使用组匹配，`match`方法不会捕获分组的内容。

设置正则表达式的`lastIndex`属性，对`match`方法无效，匹配总是从字符串的第一个字符开始。

##### replace()

字符串对象的`replace`方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。

`replace`方法的第二个参数可以使用美元符号`$`，用来指代所替换的内容。

- `$&`：匹配的子字符串。
- $`：匹配结果前面的文本。
- `$'`：匹配结果后面的文本。
- `$n`：匹配成功的第`n`组内容，`n`是从1开始的自然数。
- `$$`：指代美元符号`$`。

第二个参数也可以是一个函数，该函数的返回值将替换掉第一个参数匹配的文本

> 这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。

##### split()

字符串对象的`split`方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。

该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数。

如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。

##### matchAll()

如果一个正则表达式在字符串里面有多个匹配，现在一般使用`g`修饰符或`y`修饰符，利用exec()方法循环取出。

[ES2020](https://github.com/tc39/proposal-string-matchall) 增加了`String.prototype.matchAll()`方法，可以一次性取出所有匹配。

## 正则语法

### 元字符

“元字符”是指一位指定类型的字符

| 元字符 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| .      | 匹配除回车（`\r`）、换行(`\n`) 、行分隔符（`\u2028`）和段分隔符（`\u2029`）以外的所有字符 |
| ^      | 匹配开头                                                     |
| $      | 匹配结尾                                                     |
| \|     | 表示匹配指定几项之间的一项                                   |

在特殊字符之前的反斜杠\表示下一个字符不是特殊字符，应该按照字面理解

### 预定义模式

| 预定义模式 | 说明                                     |
| ---------- | ---------------------------------------- |
| \d         | 匹配一个数字                             |
| \D         | 匹配一个非数字字符                       |
| \w         | 匹配一个单字字符(字母、数字或者下划线)   |
| \W         | 匹配一个非单字字符                       |
| \s         | 匹配空格（包括换行符、制表符、空格符等） |
| \S         | 匹配非空格的字符                         |
| \b         | 匹配词的边界                             |
| \B         | 匹配非词的边界                           |

### 方括号表示法

使用方括号，比如[xyz]，可以创建一个字符集合，表示匹配方括号中的任意字符

可以使用短横-来指定一个字符范围，^表示否定

| 元字符 | 等价的方括号表示 |
| ------ | ---------------- |
| \d     | [0-9]            |
| \D     | [^0-9]           |
| \w     | [A-Za-z0-9_]     |
| \W     | [^A-Za-z0-9_]    |

### 量词

| 量词  | 说明                                                |
| ----- | --------------------------------------------------- |
| *     | 匹配前一个表达式0次或多次。                         |
| +     | 等价于{0,}匹配前面一个表达式1次或者多次。等价于{1,} |
| ？    | 匹配前面一个表达式0次或者1次。等价于{0,1}           |
| {n}   | n是一个正整数，匹配了前面一个字符刚好出现了n次      |
| {n,}  | n是一个正整数，匹配前一个字符至少出现了n次          |
| {n,m} | n和m都是整数。匹配前面的字符至少n次，最多m次        |

#### 贪婪模式

量词符，默认情况下都是最大可能匹配，即匹配到下一个字符不满足匹配规则为止。这被称为贪婪模式。

除了贪婪模式，还有非贪婪模式，即最小可能匹配。只要一发现匹配，就返回结果，不要往下检查。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。

### 组匹配

正则表达式使用圆括号进行组匹配。组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号引用，要是组的顺序变了，引用的时候就必须修改序号。

#### 具名组匹配

ES2018 引入了[具名组匹配](https://github.com/tc39/proposal-regexp-named-groups)（Named Capture Groups），允许为每一个组匹配指定一个名字。

```javascript
const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // "1999"
const month = matchObj.groups.month; // "12"
const day = matchObj.groups.day; // "31"
```

* 如果具名组没有匹配，那么对应的`groups`对象属性会是`undefined`。
* 字符串替换时，使用`$<组名>`引用具名组。
* replace方法第二个参数为函数时，具名组匹配给该函数新增了最后一个参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。
* 如果要在正则表达式内部引用某个“具名组匹配”，可以使用`\k<组名>`的写法。

#### 非匹配组

`(?:x)`称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

#### 先行断言

“先行断言”指的是，`x`只有在`y`前面才匹配，必须写成`/x(?=y)/`。比如，只匹配百分号之前的数字，要写成`/\d+(?=%)/`。

“先行否定断言”指的是，`x`只有不在`y`前面才匹配，必须写成`/x(?!y)/`。比如，只匹配不在百分号之前的数字，要写成`/\d+(?!%)/`。“先行断言”括号之中的部分（`(?=%)`），是不计入返回结果的。

#### 后行断言

ES2018 引入[后行断言](https://github.com/tc39/proposal-regexp-lookbehind)，V8 引擎 4.9 版（Chrome 62）已经支持。

“后行断言”正好与“先行断言”相反，`x`只有在`y`后面才匹配，必须写成`/(?<=y)x/`。比如，只匹配美元符号之后的数字，要写成`/(?<=\$)\d+/`。“后行否定断言”则与“先行否定断言”相反，`x`只有不在`y`后面才匹配，必须写成`/(?<!y)x/`。比如，只匹配不在美元符号后面的数字，要写成`/(?<!\$)\d+/`。

### 修饰符

修饰符也叫作标志(flags)，用于使用正则表达式实现高级搜索，ES6 为正则表达式新增了`flags`属性，会返回正则表达式的修饰符。

| 修饰符 | 说明                                                   |
| ------ | ------------------------------------------------------ |
| i      | 不区分大小写搜索                                       |
| g      | 全局搜索                                               |
| m      | 多行查找，修改`^`和`$`的行为                           |
| u      | 用来正确处理大于`\uFFFF`的 Unicode 字符                |
| y      | 全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始 |
| s      | 使得`.`可以匹配任意单个字符。                          |

修饰符的使用

```javascript
var re = /m/gi;
var re = new RegExp('m','gi');
```

#### u修饰符

ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，加了`u`修饰符以后，ES6 就会识别其为一个字符。

**点字符**

点（`.`）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于`0xFFFF`的 Unicode 字符，点字符不能识别，必须加上`u`修饰符。

**Unicode 字符表示法**

ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上`u`修饰符，才能识别当中的大括号，否则会被解读为量词。

**量词**

使用`u`修饰符后，所有量词都会正确识别码点大于`0xFFFF`的 Unicode 字符。

**预定义模式**

`\S`是预定义模式，匹配所有非空白字符。只有加了`u`修饰符，它才能正确匹配码点大于`0xFFFF`的 Unicode 字符。

```javascript
// 正确返回字符串长度
function codePointLength(text) {
    const result = text?.match(/[\s\S]/gu);
    return result?.length ?? 0;
}
```

#### y修饰符

ES6 还为正则表达式添加了`y`修饰符，叫做“粘连”（sticky）修饰符。

`y`修饰符的设计本意，就是让头部匹配的标志`^`在全局匹配中都有效。

ES6 的正则实例对象多了`sticky`属性，表示是否设置了`y`修饰符。

#### s修饰符

正则表达式中，点（`.`）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用`u`修饰符解决；另一个是行终止符。

ES2018 [引入](https://github.com/tc39/proposal-regexp-dotall-flag)`s`修饰符，使得`.`可以匹配任意单个字符。这被称为`dotAll`模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个`dotAll`属性，返回一个布尔值，表示该正则表达式是否处在`dotAll`模式。

#### d修饰符

组匹配的结果，在原始字符串里面的开始位置和结束位置，目前获取并不是很方便。正则实例的`exec()`方法有一个`index`属性，可以获取整个匹配结果的开始位置。但是，组匹配的每个组的开始位置，很难拿到。

[ES2022](https://github.com/tc39/proposal-regexp-match-Indices) 新增了`d`修饰符，这个修饰符可以让`exec()`、`match()`的返回结果添加`indices`属性，在该属性上面可以拿到匹配的开始位置和结束位置。

* 如果正则表达式包含组匹配，那么`indices`属性对应的数组就会包含多个成员，提供每个组匹配的开始位置和结束位置。
* 如果正则表达式包含具名组匹配，`indices`属性数组还会有一个`groups`属性。该属性是一个对象，可以从该对象获取具名组匹配的开始位置和结束位置。
* 如果获取组匹配不成功，`indices`属性数组的对应成员则为`undefined`，`indices.groups`属性对象的对应成员也是`undefined`。

#### v修饰符

需要向某个 Unicode 属性类添加或减少字符，即需要对属性类进行运算。现在有一个[提案](https://github.com/tc39/proposal-regexp-v-flag)，增加了 Unicode 属性类的运算功能。

它提供两种形式的运算，一种是差集运算（A 集合减去 B 集合），另一种是交集运算。

```javascript
// 差集运算（A 减去 B）
[A--B]

// 交集运算（A 与 B 的交集）
[A&&B]
```

**属性类**

ES2018 [引入](https://github.com/tc39/proposal-regexp-unicode-property-escapes)了 Unicode 属性类，允许使用`\p{...}`和`\P{...}`（`\P`是`\p`的否定形式）代表一类 Unicode 字符，匹配满足条件的所有字符。

```javascript
const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test('π') // true
```

这两种类只对 Unicode 有效，所以使用的时候一定要加上`u`修饰符
