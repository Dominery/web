# 内存管理

### 代际假说

提高垃圾回收的效率，V8将堆分为新生代和老生代两个部分。

1. 新生代为 存活时间较短 的对象(需要经常进行垃圾回收)，内存占用小，GC频繁； 
2. 而老生代为 存活时间较长 的对象(垃圾回收的频率较低)，内存占用多，GC不频繁；

64位下新生代的空间为64M，老生代为1400M 32位下新生代的空间为16M，老生代为700M.

## V8垃圾回收机制

### 新生代算法

在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间，使用Scanvenge算法。

新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。

发生下面的情况，新生代对象会转移到老生代空间。

- 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
- To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。

### 老生代算法

老生代空间使用标记清除算法、标记压缩算法。

标记清除算法会遍历堆中所有的对象，然后标记活的对象，在标记完成后，进行第二次遍历，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。

清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。